"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegisterBrowserEventsHandler = void 0;
var register_events_handler_base_1 = require("./register-events-handler.base");
/**
 * Registers a global event handler that will trigger Browser Events in Bugfender
 */
var RegisterBrowserEventsHandler = /** @class */ (function (_super) {
    __extends(RegisterBrowserEventsHandler, _super);
    function RegisterBrowserEventsHandler(bugfender, window) {
        var _this = _super.call(this, bugfender, window) || this;
        _this.bugfender = bugfender;
        _this.window = window;
        return _this;
    }
    RegisterBrowserEventsHandler.prototype.init = function () {
        var _this = this;
        if (!this.window.document.addEventListener) {
            return;
        }
        // Init event listener options
        var options = this.supportsPassiveEvents() ? { passive: true, capture: true } : true;
        // Page Loaded event
        this.window.addEventListener("load", function () {
            _this.addJsEventLogEntry({
                event: "PageLoaded",
                performance: _this.window.performance,
            });
        }, options);
        // DOMContent Loaded event
        this.window.addEventListener("DOMContentLoaded", function () {
            _this.addJsEventLogEntry({
                event: "DOMContentLoaded",
            });
        }, options);
        // POP State event
        this.window.addEventListener("popstate", function (e) {
            _this.addJsEventLogEntry({
                event: "popstate",
                location: _this.window.location.href,
                state: JSON.stringify(e.state),
            });
        }, options);
        // Hash Change event
        this.window.addEventListener("hashchange", function () {
            _this.addJsEventLogEntry({
                event: "hashchange",
                hash: _this.window.location.hash,
            });
        }, options);
        // Override history.pushState methods
        var historyOverrideFnFactory = function (originalFn) {
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            var self = _this;
            // Return the function that will override `pushState/replaceState`
            // In this case we add our functionality & then delegate to the original implementation
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var url = args.length > 2 ? args[2] : undefined;
                if (url) {
                    self.addJsEventLogEntry({
                        event: "pushstate",
                        to: String(url),
                        state: args.length > 1 ? JSON.stringify(args[1]) : null,
                    });
                }
                return originalFn.apply(this, args);
            };
        };
        this.override(this.window.history, "pushState", historyOverrideFnFactory);
        this.override(this.window.history, "replaceState", historyOverrideFnFactory);
    };
    /**
     * Wrap a given object method with a higher-order function
     *
     * @param object The object that contains the method to be wrapped.
     * @param method Name of method to be wrapped.
     * @param overrideFactory Factory function that returns the function that will override the original method
     */
    RegisterBrowserEventsHandler.prototype.override = function (object, method, overrideFactory) {
        if (!(method in object)) {
            return;
        }
        var original = object[method];
        var wrapped = overrideFactory(original);
        object[method] = wrapped;
    };
    return RegisterBrowserEventsHandler;
}(register_events_handler_base_1.RegisterEventsHandlerBase));
exports.RegisterBrowserEventsHandler = RegisterBrowserEventsHandler;
