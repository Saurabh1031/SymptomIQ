"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegisterUIEventsHandler = void 0;
var utils_1 = require("../utils");
var register_events_handler_base_1 = require("./register-events-handler.base");
/**
 * Registers a global event handler that will trigger UI Events in Bugfender
 */
var RegisterUIEventsHandler = /** @class */ (function (_super) {
    __extends(RegisterUIEventsHandler, _super);
    function RegisterUIEventsHandler(bugfender, window) {
        var _this = _super.call(this, bugfender, window) || this;
        _this.bugfender = bugfender;
        _this.window = window;
        return _this;
    }
    RegisterUIEventsHandler.prototype.init = function () {
        var _this = this;
        if (!this.window.document.addEventListener) {
            return;
        }
        // Init event listener options
        var options = this.supportsPassiveEvents() ? { passive: true, capture: true } : true;
        //Click event
        this.window.document.addEventListener("click", function (e) {
            if (e.target instanceof Element) {
                _this.addJsEventLogEntry(_this.getEventData(e.target, "click"));
            }
        }, options);
        //Focus event
        this.window.document.addEventListener("focusin", function (e) {
            if (e.target instanceof Element) {
                _this.addJsEventLogEntry(_this.getEventData(e.target, "focus"));
            }
        }, options);
        //Blur event
        this.window.document.addEventListener("focusout", function (e) {
            if (e.target instanceof Element) {
                _this.addJsEventLogEntry(_this.getEventData(e.target, "blur"));
            }
        }, options);
        // Submit
        this.window.addEventListener("submit", function (e) {
            if (e.target instanceof Element) {
                _this.addJsEventLogEntry(_this.getEventData(e.target, "submit"));
            }
        }, options);
        // Keyboard logging
        var debounceByEl = new utils_1.DebounceByElement(400);
        var ignoreList = [
            "Tab",
            "Meta",
            "MetaLeft",
            "MetaRight",
            "Alt",
            "AltLeft",
            "AltRight",
            "Control",
            "ControlLeft",
            "ControlRight",
            "Shift",
            "ShiftLeft",
            "ShiftRight",
            "ArrowLeft",
            "ArrowUp",
            "ArrowRight",
            "ArrowDown",
            "PageDown",
            "PageUp",
            "Home",
            "End",
            "CapsLock",
        ];
        this.window.addEventListener("keyup", function (e) {
            // The event target must be an `input` or `textarea` element
            // We don't support older browser that can't give us the event target DOM path
            // Ignore some keypress events
            if (!(e.target instanceof HTMLInputElement ||
                e.target instanceof HTMLTextAreaElement) ||
                !e.composedPath ||
                ignoreList.includes(e.code)) {
                return;
            }
            // This is just a work-around to keep the narrowed type (Input | Textarea) inside the debounce callback
            var target = e.target;
            var path = e.composedPath();
            debounceByEl.run(target, function () {
                _this.sendKeyupLog(target, path);
            });
        }, options);
    };
    RegisterUIEventsHandler.prototype.sendKeyupLog = function (target, path) {
        var _a;
        var isPasswordEl = ((_a = target.getAttribute("type")) !== null && _a !== void 0 ? _a : "").toLowerCase() === "password";
        var shouldSkipKeyLogging = path
            .filter(function (el) { return el instanceof HTMLElement; }) // Skip some parent elements, e.g. `window` is not `HTMLElement`
            .some(function (el) { return "bfIgnoreKeypress" in el.dataset; }); // Check for `data-bf-ignore-keypress`
        var shouldOmitText = isPasswordEl || shouldSkipKeyLogging;
        this.addJsEventLogEntry(__assign(__assign({}, this.getEventData(target, "keyup")), { text: shouldOmitText ? undefined : target.value }));
    };
    /**
     * Fills and object with data from an event
     */
    RegisterUIEventsHandler.prototype.getEventData = function (target, eventName) {
        var text = target.childElementCount <= 1 ? target.textContent : undefined;
        var form = target.tagName === "FORM" ? target : null;
        return {
            event: eventName,
            url: this.window ? this.window.location.href : "",
            xpath: (0, utils_1.getXPath)(target),
            tag: target.tagName,
            id: target.id,
            text: text !== null && text !== void 0 ? text : undefined,
            action: form && form.action ? form.action : "",
        };
    };
    return RegisterUIEventsHandler;
}(register_events_handler_base_1.RegisterEventsHandlerBase));
exports.RegisterUIEventsHandler = RegisterUIEventsHandler;
