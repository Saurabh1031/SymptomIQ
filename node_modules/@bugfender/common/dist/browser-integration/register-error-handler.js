"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegisterErrorHandler = void 0;
/**
 * Registers a global error handler that will trigger a crash report in Bugfender
 * @internal
 */
var RegisterErrorHandler = /** @class */ (function () {
    function RegisterErrorHandler(window) {
        this.window = window;
        this.rejectionsMap = new Map();
    }
    RegisterErrorHandler.prototype.init = function (bugfender) {
        var _this = this;
        this.bugfender = bugfender;
        // Regular errors
        this.window.addEventListener('error', function (e) {
            var msg = e.message, line = e.lineno, filename = e.filename, error = e.error;
            _this.logError(msg, filename, line, error);
        });
        // Promise errors
        // This is not the best solution as it introduces a slight delay in the error reporting.
        this.window.addEventListener('unhandledrejection', function (e) {
            // Wait 1ms before reporting the error, this way we report errors that are not being handled in the same "tick"
            var timeoutId = setTimeout(function () {
                _this.logError("Potentially unhandled promise", undefined, undefined, e.reason);
            }, 1);
            // Save the reference to the `setTimeout`
            _this.rejectionsMap.set(e.promise, timeoutId);
            e.preventDefault();
        });
        this.window.addEventListener('rejectionhandled', function (e) {
            // Promise has been handled, abort error reporting by clearing the `setTimeout`
            clearTimeout(_this.rejectionsMap.get(e.promise));
            _this.rejectionsMap.delete(e.promise);
        });
    };
    RegisterErrorHandler.prototype.logError = function (msg, filename, line, error) {
        var stack;
        if (error && error.stack) {
            stack = error.stack;
        }
        if (typeof msg === 'string') {
            this.bugfender.sendCrash(msg, [
                "Error: ".concat(msg),
                "URL: ".concat(filename !== null && filename !== void 0 ? filename : 'N/A'),
                "Line: ".concat(line !== null && line !== void 0 ? line : 'N/A'),
                "Stack: ".concat(stack !== null && stack !== void 0 ? stack : 'N/A'),
            ].join('\n'));
        }
    };
    return RegisterErrorHandler;
}());
exports.RegisterErrorHandler = RegisterErrorHandler;
