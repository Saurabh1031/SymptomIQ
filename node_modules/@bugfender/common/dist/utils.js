"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnreachableCaseError = exports.getElByXPath = exports.getXPath = exports.DebounceByElement = void 0;
var DebounceByElement = /** @class */ (function () {
    function DebounceByElement(wait) {
        this.wait = wait;
        this.timers = new Map();
    }
    /**
     * Run provided callback when there wasn't activity for `wait` time
     *
     * @param el Element which is used to bind the debounce timer
     * @param cb Callback to run after `wait` has ellapsed without activity
     */
    DebounceByElement.prototype.run = function (el, cb) {
        var _this = this;
        if (this.timers.has(el)) {
            // SAFETY `!`: We know the timer exists as we've just checked it
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            clearTimeout(this.timers.get(el));
        }
        this.timers.set(el, setTimeout(function () {
            cb(); // Run callback
            _this.timers.delete(el);
        }, this.wait));
    };
    return DebounceByElement;
}());
exports.DebounceByElement = DebounceByElement;
// XPath Utilities
function getXPath(el) {
    var nodeElem = el;
    if (nodeElem instanceof Element && nodeElem.id) {
        return "//*[@id=\"" + nodeElem.id + "\"]";
    }
    var parts = [];
    while (nodeElem && nodeElem instanceof Element) {
        var currEl = nodeElem;
        var nbOfPreviousSiblings = 0;
        var hasNextSiblings = false;
        var sibling = currEl.previousSibling;
        while (sibling) {
            if (sibling.nodeType !== Node.DOCUMENT_TYPE_NODE &&
                sibling.nodeName === currEl.nodeName) {
                nbOfPreviousSiblings++;
            }
            sibling = sibling.previousSibling;
        }
        sibling = currEl.nextSibling;
        while (sibling) {
            if (sibling.nodeName === currEl.nodeName) {
                hasNextSiblings = true;
                break;
            }
            sibling = sibling.nextSibling;
        }
        var prefix = currEl.prefix ? currEl.prefix + ":" : "";
        var nth = nbOfPreviousSiblings || hasNextSiblings
            ? "[".concat(nbOfPreviousSiblings + 1, "]")
            : "";
        parts.push(prefix + currEl.localName + nth);
        nodeElem = currEl.parentNode;
    }
    return parts.length ? "/" + parts.reverse().join("/") : "";
}
exports.getXPath = getXPath;
function getElByXPath(xpath) {
    var _a;
    return ((_a = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue) !== null && _a !== void 0 ? _a : undefined);
}
exports.getElByXPath = getElByXPath;
var UnreachableCaseError = /** @class */ (function (_super) {
    __extends(UnreachableCaseError, _super);
    function UnreachableCaseError(val) {
        return _super.call(this, "Unreachable case: ".concat(JSON.stringify(val))) || this;
    }
    return UnreachableCaseError;
}(Error));
exports.UnreachableCaseError = UnreachableCaseError;
