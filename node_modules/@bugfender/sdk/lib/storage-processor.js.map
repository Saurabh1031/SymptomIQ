{"version":3,"file":"storage-processor.js","mappings":"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","sources":["webpack://@bugfender/sdk/webpack/universalModuleDefinition","webpack://@bugfender/sdk/webpack/startup","webpack://@bugfender/sdk/./src/storage-processor.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"@bugfender/sdk\"] = factory();\n\telse\n\t\troot[\"@bugfender/sdk\"] = factory();\n})(self, () => {\nreturn ","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[3103](0, __webpack_exports__);\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StorageProcessor = void 0;\nclass StorageProcessor {\n    constructor(api, channel, connection, logger, device, deviceKeysTable, issuesTable, logsTable, options, sessionFactory, sessionsTable, storageGuard) {\n        this.api = api;\n        this.channel = channel;\n        this.connection = connection;\n        this.logger = logger;\n        this.device = device;\n        this.deviceKeysTable = deviceKeysTable;\n        this.issuesTable = issuesTable;\n        this.logsTable = logsTable;\n        this.options = options;\n        this.sessionFactory = sessionFactory;\n        this.sessionsTable = sessionsTable;\n        this.storageGuard = storageGuard;\n        this.BATCH_SIZE = 500;\n        this.runIntervalMs = 15000;\n        this.forceSend = false;\n        this.isRunning = false;\n        setInterval(this.run.bind(this), this.runIntervalMs);\n        this.channel.onHasBecomeLeader().then(() => {\n            this.run();\n        });\n        this.channel.onForceSend(() => {\n            this.forceSend = true;\n        });\n    }\n    cleanupSessions(sessions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const session of sessions) {\n                const hasActiveTab = yield this.channel.isSessionActive(session.uuid);\n                const hasData = yield this.hasData(session);\n                const shouldDelete = !hasActiveTab && !hasData;\n                if (shouldDelete) {\n                    try {\n                        yield this.sessionsTable.delete(session.uuid);\n                    }\n                    catch (err) {\n                    }\n                }\n            }\n        });\n    }\n    hasData(session) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const [logsCount, issuesCount, deviceKeysCount] = yield Promise.all([\n                    this.logsTable.count(session.uuid),\n                    this.issuesTable.count(session.uuid),\n                    this.deviceKeysTable.count(session.uuid),\n                ]);\n                return logsCount > 0 || issuesCount > 0 || deviceKeysCount > 0;\n            }\n            catch (err) {\n                return true;\n            }\n        });\n    }\n    registerSession(sessionIDB) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!sessionIDB.id) {\n                const session = this.sessionFactory.create(sessionIDB.uuid, this.options);\n                const { id } = yield this.api.sendSession(session);\n                sessionIDB.id = id;\n                this.sessionsTable.update(sessionIDB.uuid, { id });\n            }\n            return sessionIDB;\n        });\n    }\n    canRun() {\n        return (this.connection.isOnline() &&\n            this.channel.isLeader() &&\n            !this.isRunning);\n    }\n    run() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const canRun = this.canRun();\n            this.logger.log('Processing...', {\n                forceSend: this.forceSend,\n                isRunning: this.isRunning,\n                isLeader: this.channel.isLeader(),\n                isOnline: this.connection.isOnline(),\n                canRun,\n            });\n            if (!canRun) {\n                this.logger.log('Aborted.');\n                return;\n            }\n            this.isRunning = true;\n            const isForceSend = this.forceSend;\n            const sessions = yield this.sessionsTable.getAll();\n            const apiPromises = [];\n            const shouldProcess = this.storageGuard.canProcess() || this.forceSend;\n            let hadIssues = false;\n            this.logger.log(`Should process device: ${shouldProcess ? 'Yes' : 'No'}`);\n            this.logger.log(`${sessions.length} session/s found`);\n            sessions.sort((a, b) => Number(!!b.id) - Number(!!a.id));\n            for (const partialSession of sessions) {\n                const session = yield this.registerSession(partialSession);\n                const sessionHasIssues = yield this.sendIssues(session);\n                hadIssues = hadIssues || sessionHasIssues;\n                if (sessionHasIssues || shouldProcess) {\n                    apiPromises.push(this.sendLogs(session));\n                    this.logger.log(`Session processed. ID: ${session.id}`, { sessionHasIssues });\n                }\n                else {\n                    this.logger.log(`Session skipped. ID: ${session.id}`);\n                }\n            }\n            if (hadIssues || shouldProcess) {\n                apiPromises.push(this.sendDeviceData());\n            }\n            yield Promise.all(apiPromises);\n            yield this.cleanupSessions(sessions);\n            this.isRunning = false;\n            if (isForceSend) {\n                this.forceSend = false;\n            }\n            this.logger.log('Done');\n        });\n    }\n    sendDeviceData() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const deviceKeyChanges = {};\n                const deviceKeys = yield this.deviceKeysTable.getAll();\n                deviceKeys.forEach(entry => {\n                    deviceKeyChanges[entry.data.key] = entry.data.value;\n                });\n                if (deviceKeys.length) {\n                    yield Promise.all(Object.entries(deviceKeyChanges)\n                        .map(([key, value]) => this.api.setDeviceKey(this.device.getUDID(), key, value)));\n                    yield this.deviceKeysTable.deleteBatch(deviceKeys.length);\n                }\n            }\n            catch (err) {\n                this.logger.error('sendDeviceData error', err);\n            }\n        });\n    }\n    sendIssues(session) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const entries = yield this.issuesTable.getBatch(session.uuid, this.BATCH_SIZE);\n                for (const entry of entries) {\n                    const issue = entry.data;\n                    const issueURL = `${this.options.baseURL}/intent/${this.options.appID}/issue/${issue.uuid}`;\n                    yield this.api.sendIssue(issue.uuid, issueURL, issue.title, issue.text, issue.type, session.id);\n                    yield this.issuesTable.deleteById(entry.id);\n                }\n                return entries.length > 0;\n            }\n            catch (err) {\n                this.logger.error('sendIssues error', err);\n                return false;\n            }\n        });\n    }\n    sendLogs(session) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const entries = yield this.logsTable.getBatch(session.uuid, this.BATCH_SIZE);\n                const logs = entries.map(entry => entry.data);\n                if (logs.length) {\n                    yield this.api.sendLogs(session.id, logs);\n                    yield this.logsTable.deleteBatch(session.uuid, logs.length);\n                }\n            }\n            catch (err) {\n                this.logger.error('sendLogs error', err);\n            }\n        });\n    }\n}\nexports.StorageProcessor = StorageProcessor;\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_exports__","__awaiter","this","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Object","defineProperty","StorageProcessor","constructor","api","channel","connection","logger","device","deviceKeysTable","issuesTable","logsTable","options","sessionFactory","sessionsTable","storageGuard","BATCH_SIZE","runIntervalMs","forceSend","isRunning","setInterval","run","bind","onHasBecomeLeader","onForceSend","cleanupSessions","sessions","session","hasActiveTab","isSessionActive","uuid","hasData","delete","err","logsCount","issuesCount","deviceKeysCount","all","count","registerSession","sessionIDB","id","create","sendSession","update","canRun","isOnline","isLeader","log","isForceSend","getAll","apiPromises","shouldProcess","canProcess","hadIssues","length","sort","a","b","Number","partialSession","sessionHasIssues","sendIssues","push","sendLogs","sendDeviceData","deviceKeyChanges","deviceKeys","forEach","entry","data","key","entries","map","setDeviceKey","getUDID","deleteBatch","error","getBatch","issue","issueURL","baseURL","appID","sendIssue","title","text","type","deleteById","logs"],"sourceRoot":""}