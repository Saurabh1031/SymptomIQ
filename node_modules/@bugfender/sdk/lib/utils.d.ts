interface BaseDeferred<T, E> {
    isFulfilled: boolean;
    isResolved: boolean;
    isRejected: boolean;
    promise: Promise<T>;
    resolve: (value: T) => void;
    reject: (reason: E) => void;
}
interface DeferredPending<T, E> extends BaseDeferred<T, E> {
    isFullfilled: false;
    isRejected: false;
    isResolved: false;
}
interface DeferredResolved<T, E> extends BaseDeferred<T, E> {
    isFulfilled: true;
    isRejected: false;
    isResolved: true;
    value: T;
}
interface DeferredRejected<T, E> extends BaseDeferred<T, E> {
    isFulfilled: true;
    isRejected: true;
    isResolved: false;
    err: E;
}
export type Deferred<T, E = unknown> = DeferredPending<T, E> | DeferredResolved<T, E> | DeferredRejected<T, E>;
export declare function createDeferred<T, E = unknown>(): Deferred<T, E>;
export declare function CacheDecoratorFactory(cache: Map<string, unknown>): () => (_: unknown, propertyKey: string, descriptor: PropertyDescriptor) => void;
export declare class UnreachableCaseError extends Error {
    constructor(val: never);
}
export declare class DebounceByElement {
    private readonly wait;
    private timers;
    constructor(wait: number);
    run(el: HTMLElement, cb: () => void): void;
}
export declare function getXPath(el: Node): string;
export declare function getElByXPath(xpath: string): Node | undefined;
export {};
