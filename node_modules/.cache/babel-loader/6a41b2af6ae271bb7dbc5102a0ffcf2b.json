{"ast":null,"code":"/*! @azure/msal-browser v2.38.3 2023-10-27 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { Constants } from '@azure/msal-common';\nimport { KEY_FORMAT_JWK } from '../utils/BrowserConstants.js';\nimport { BrowserStringUtils } from '../utils/BrowserStringUtils.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nvar MsBrowserCrypto = /** @class */function () {\n  function MsBrowserCrypto() {}\n  MsBrowserCrypto.prototype.getRandomValues = function (dataBuffer) {\n    return window[\"msCrypto\"].getRandomValues(dataBuffer);\n  };\n  MsBrowserCrypto.prototype.generateKey = function (algorithm, extractable, keyUsages) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, new Promise(function (resolve, reject) {\n          var msGenerateKey = window[\"msCrypto\"].subtle.generateKey(algorithm, extractable, keyUsages);\n          msGenerateKey.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          msGenerateKey.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  MsBrowserCrypto.prototype.exportKey = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, new Promise(function (resolve, reject) {\n          var msExportKey = window[\"msCrypto\"].subtle.exportKey(KEY_FORMAT_JWK, key);\n          msExportKey.addEventListener(\"complete\", function (e) {\n            var resultBuffer = e.target.result;\n            var resultString = BrowserStringUtils.utf8ArrToString(new Uint8Array(resultBuffer)).replace(/\\r/g, Constants.EMPTY_STRING).replace(/\\n/g, Constants.EMPTY_STRING).replace(/\\t/g, Constants.EMPTY_STRING).split(\" \").join(Constants.EMPTY_STRING).replace(\"\\u0000\", Constants.EMPTY_STRING);\n            try {\n              resolve(JSON.parse(resultString));\n            } catch (e) {\n              reject(e);\n            }\n          });\n          msExportKey.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  MsBrowserCrypto.prototype.importKey = function (keyData, algorithm, extractable, keyUsages) {\n    return __awaiter(this, void 0, void 0, function () {\n      var keyString, keyBuffer;\n      return __generator(this, function (_a) {\n        keyString = BrowserStringUtils.getSortedObjectString(keyData);\n        keyBuffer = BrowserStringUtils.stringToArrayBuffer(keyString);\n        return [2 /*return*/, new Promise(function (resolve, reject) {\n          var msImportKey = window[\"msCrypto\"].subtle.importKey(KEY_FORMAT_JWK, keyBuffer, algorithm, extractable, keyUsages);\n          msImportKey.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          msImportKey.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  MsBrowserCrypto.prototype.sign = function (algorithm, key, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, new Promise(function (resolve, reject) {\n          var msSign = window[\"msCrypto\"].subtle.sign(algorithm, key, data);\n          msSign.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          msSign.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  MsBrowserCrypto.prototype.digest = function (algorithm, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, new Promise(function (resolve, reject) {\n          var digestOperation = window[\"msCrypto\"].subtle.digest(algorithm, data.buffer);\n          digestOperation.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          digestOperation.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  return MsBrowserCrypto;\n}();\nexport { MsBrowserCrypto };","map":{"version":3,"sources":["../../src/crypto/MsBrowserCrypto.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { Constants } from \"@azure/msal-common\";\r\nimport { KEY_FORMAT_JWK } from \"../utils/BrowserConstants\";\r\nimport { BrowserStringUtils } from \"../utils/BrowserStringUtils\";\r\nimport { ISubtleCrypto } from \"./ISubtleCrypto\";\r\n\r\nexport class MsBrowserCrypto implements ISubtleCrypto {\r\n    getRandomValues(dataBuffer: Uint8Array): Uint8Array {\r\n        return window[\"msCrypto\"].getRandomValues(dataBuffer);\r\n    }\r\n\r\n    async generateKey(algorithm: RsaHashedKeyGenParams, extractable: boolean, keyUsages: KeyUsage[]): Promise<CryptoKeyPair> {\r\n        return new Promise((resolve: Function, reject: Function) => {\r\n            const msGenerateKey = window[\"msCrypto\"].subtle.generateKey(algorithm, extractable, keyUsages);\r\n            msGenerateKey.addEventListener(\"complete\", (e: { target: { result: CryptoKeyPair | PromiseLike<CryptoKeyPair>; }; }) => {\r\n                resolve(e.target.result);\r\n            });\r\n\r\n            msGenerateKey.addEventListener(\"error\", (error: string) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n\r\n    async exportKey(key: CryptoKey): Promise<JsonWebKey> {\r\n        return new Promise((resolve: Function, reject: Function) => {\r\n            const msExportKey = window[\"msCrypto\"].subtle.exportKey(KEY_FORMAT_JWK, key);\r\n            msExportKey.addEventListener(\"complete\", (e: { target: { result: ArrayBuffer; }; }) => {\r\n                const resultBuffer: ArrayBuffer = e.target.result;\r\n\r\n                const resultString = BrowserStringUtils.utf8ArrToString(new Uint8Array(resultBuffer))\r\n                    .replace(/\\r/g, Constants.EMPTY_STRING)\r\n                    .replace(/\\n/g, Constants.EMPTY_STRING)\r\n                    .replace(/\\t/g, Constants.EMPTY_STRING)\r\n                    .split(\" \").join(Constants.EMPTY_STRING)\r\n                    .replace(\"\\u0000\", Constants.EMPTY_STRING);\r\n\r\n                try {\r\n                    resolve(JSON.parse(resultString));\r\n                } catch (e) {\r\n                    reject(e);\r\n                }\r\n            });\r\n\r\n            msExportKey.addEventListener(\"error\", (error: string) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n\r\n    async importKey(keyData: JsonWebKey, algorithm: RsaHashedImportParams, extractable: boolean, keyUsages: KeyUsage[]): Promise<CryptoKey> {\r\n        const keyString = BrowserStringUtils.getSortedObjectString(keyData);\r\n        const keyBuffer = BrowserStringUtils.stringToArrayBuffer(keyString);\r\n\r\n        return new Promise((resolve: Function, reject: Function) => {\r\n            const msImportKey = window[\"msCrypto\"].subtle.importKey(KEY_FORMAT_JWK, keyBuffer, algorithm, extractable, keyUsages);\r\n            msImportKey.addEventListener(\"complete\", (e: { target: { result: CryptoKey | PromiseLike<CryptoKey>; }; }) => {\r\n                resolve(e.target.result);\r\n            });\r\n\r\n            msImportKey.addEventListener(\"error\", (error: string) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n\r\n    async sign(algorithm: AlgorithmIdentifier, key: CryptoKey, data: ArrayBuffer): Promise<ArrayBuffer> {\r\n        return new Promise((resolve: Function, reject: Function) => {\r\n            const msSign = window[\"msCrypto\"].subtle.sign(algorithm, key, data);\r\n            msSign.addEventListener(\"complete\", (e: { target: { result: ArrayBuffer | PromiseLike<ArrayBuffer>; }; }) => {\r\n                resolve(e.target.result);\r\n            });\r\n\r\n            msSign.addEventListener(\"error\", (error: string) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n    \r\n    async digest(algorithm: AlgorithmIdentifier, data: Uint8Array): Promise<ArrayBuffer> {\r\n        return new Promise((resolve, reject) => {\r\n            const digestOperation = window[\"msCrypto\"].subtle.digest(algorithm, data.buffer);\r\n            digestOperation.addEventListener(\"complete\", (e: { target: { result: ArrayBuffer | PromiseLike<ArrayBuffer>; }; }) => {\r\n                resolve(e.target.result);\r\n            });\r\n            digestOperation.addEventListener(\"error\", (error: string) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}