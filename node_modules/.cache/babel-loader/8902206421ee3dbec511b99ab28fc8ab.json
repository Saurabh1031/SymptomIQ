{"ast":null,"code":"/*! @azure/msal-common v13.3.1 2023-10-27 */\n'use strict';\n\nimport { Separators, CacheAccountType, CacheType, Constants } from '../../utils/Constants.js';\nimport { buildClientInfo } from '../../account/ClientInfo.js';\nimport { StringUtils } from '../../utils/StringUtils.js';\nimport { ClientAuthError } from '../../error/ClientAuthError.js';\nimport { AuthorityType } from '../../authority/AuthorityType.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Type that defines required and optional parameters for an Account field (based on universal cache schema implemented by all MSALs).\r\n *\r\n * Key : Value Schema\r\n *\r\n * Key: <home_account_id>-<environment>-<realm*>\r\n *\r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      localAccountId: Original tenant-specific accountID, usually used for legacy cases\r\n *      username: primary username that represents the user, usually corresponds to preferred_username in the v2 endpt\r\n *      authorityType: Accounts authority type as a string\r\n *      name: Full name for the account, including given name and family name,\r\n *      clientInfo: Full base64 encoded client info received from ESTS\r\n *      lastModificationTime: last time this entity was modified in the cache\r\n *      lastModificationApp:\r\n *      idTokenClaims: Object containing claims parsed from ID token\r\n *      nativeAccountId: Account identifier on the native device\r\n * }\r\n */\nvar AccountEntity = /** @class */function () {\n  function AccountEntity() {}\n  /**\r\n   * Generate Account Id key component as per the schema: <home_account_id>-<environment>\r\n   */\n  AccountEntity.prototype.generateAccountId = function () {\n    var accountId = [this.homeAccountId, this.environment];\n    return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  };\n  /**\r\n   * Generate Account Cache Key as per the schema: <home_account_id>-<environment>-<realm*>\r\n   */\n  AccountEntity.prototype.generateAccountKey = function () {\n    return AccountEntity.generateAccountCacheKey({\n      homeAccountId: this.homeAccountId,\n      environment: this.environment,\n      tenantId: this.realm,\n      username: this.username,\n      localAccountId: this.localAccountId\n    });\n  };\n  /**\r\n   * returns the type of the cache (in this case account)\r\n   */\n  AccountEntity.prototype.generateType = function () {\n    switch (this.authorityType) {\n      case CacheAccountType.ADFS_ACCOUNT_TYPE:\n        return CacheType.ADFS;\n      case CacheAccountType.MSAV1_ACCOUNT_TYPE:\n        return CacheType.MSA;\n      case CacheAccountType.MSSTS_ACCOUNT_TYPE:\n        return CacheType.MSSTS;\n      case CacheAccountType.GENERIC_ACCOUNT_TYPE:\n        return CacheType.GENERIC;\n      default:\n        {\n          throw ClientAuthError.createUnexpectedAccountTypeError();\n        }\n    }\n  };\n  /**\r\n   * Returns the AccountInfo interface for this account.\r\n   */\n  AccountEntity.prototype.getAccountInfo = function () {\n    return {\n      homeAccountId: this.homeAccountId,\n      environment: this.environment,\n      tenantId: this.realm,\n      username: this.username,\n      localAccountId: this.localAccountId,\n      name: this.name,\n      idTokenClaims: this.idTokenClaims,\n      nativeAccountId: this.nativeAccountId\n    };\n  };\n  /**\r\n   * Generates account key from interface\r\n   * @param accountInterface\r\n   */\n  AccountEntity.generateAccountCacheKey = function (accountInterface) {\n    var accountKey = [accountInterface.homeAccountId, accountInterface.environment || Constants.EMPTY_STRING, accountInterface.tenantId || Constants.EMPTY_STRING];\n    return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  };\n  /**\r\n   * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.\r\n   * @param clientInfo\r\n   * @param authority\r\n   * @param idToken\r\n   * @param policy\r\n   */\n  AccountEntity.createAccount = function (clientInfo, homeAccountId, idToken, authority, cloudGraphHostName, msGraphHost, environment, nativeAccountId) {\n    var _a, _b, _c, _d, _e, _f;\n    var account = new AccountEntity();\n    account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;\n    account.clientInfo = clientInfo;\n    account.homeAccountId = homeAccountId;\n    account.nativeAccountId = nativeAccountId;\n    var env = environment || authority && authority.getPreferredCache();\n    if (!env) {\n      throw ClientAuthError.createInvalidCacheEnvironmentError();\n    }\n    account.environment = env;\n    // non AAD scenarios can have empty realm\n    account.realm = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.tid) || Constants.EMPTY_STRING;\n    if (idToken) {\n      account.idTokenClaims = idToken.claims;\n      // How do you account for MSA CID here?\n      account.localAccountId = ((_b = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _b === void 0 ? void 0 : _b.oid) || ((_c = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _c === void 0 ? void 0 : _c.sub) || Constants.EMPTY_STRING;\n      /*\r\n       * In B2C scenarios the emails claim is used instead of preferred_username and it is an array.\r\n       * In most cases it will contain a single email. This field should not be relied upon if a custom\r\n       * policy is configured to return more than 1 email.\r\n       */\n      var preferredUsername = (_d = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _d === void 0 ? void 0 : _d.preferred_username;\n      var email = ((_e = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _e === void 0 ? void 0 : _e.emails) ? idToken.claims.emails[0] : null;\n      account.username = preferredUsername || email || Constants.EMPTY_STRING;\n      account.name = (_f = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _f === void 0 ? void 0 : _f.name;\n    }\n    account.cloudGraphHostName = cloudGraphHostName;\n    account.msGraphHost = msGraphHost;\n    return account;\n  };\n  /**\r\n   * Builds non-AAD/ADFS account.\r\n   * @param authority\r\n   * @param idToken\r\n   */\n  AccountEntity.createGenericAccount = function (homeAccountId, idToken, authority, cloudGraphHostName, msGraphHost, environment) {\n    var _a, _b, _c, _d;\n    var account = new AccountEntity();\n    account.authorityType = authority && authority.authorityType === AuthorityType.Adfs ? CacheAccountType.ADFS_ACCOUNT_TYPE : CacheAccountType.GENERIC_ACCOUNT_TYPE;\n    account.homeAccountId = homeAccountId;\n    // non AAD scenarios can have empty realm\n    account.realm = Constants.EMPTY_STRING;\n    var env = environment || authority && authority.getPreferredCache();\n    if (!env) {\n      throw ClientAuthError.createInvalidCacheEnvironmentError();\n    }\n    if (idToken) {\n      // How do you account for MSA CID here?\n      account.localAccountId = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.oid) || ((_b = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _b === void 0 ? void 0 : _b.sub) || Constants.EMPTY_STRING;\n      // upn claim for most ADFS scenarios\n      account.username = ((_c = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _c === void 0 ? void 0 : _c.upn) || Constants.EMPTY_STRING;\n      account.name = ((_d = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _d === void 0 ? void 0 : _d.name) || Constants.EMPTY_STRING;\n      account.idTokenClaims = idToken === null || idToken === void 0 ? void 0 : idToken.claims;\n    }\n    account.environment = env;\n    account.cloudGraphHostName = cloudGraphHostName;\n    account.msGraphHost = msGraphHost;\n    /*\r\n     * add uniqueName to claims\r\n     * account.name = idToken.claims.uniqueName;\r\n     */\n    return account;\n  };\n  /**\r\n   * Generate HomeAccountId from server response\r\n   * @param serverClientInfo\r\n   * @param authType\r\n   */\n  AccountEntity.generateHomeAccountId = function (serverClientInfo, authType, logger, cryptoObj, idToken) {\n    var _a;\n    var accountId = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.sub) ? idToken.claims.sub : Constants.EMPTY_STRING;\n    // since ADFS does not have tid and does not set client_info\n    if (authType === AuthorityType.Adfs || authType === AuthorityType.Dsts) {\n      return accountId;\n    }\n    // for cases where there is clientInfo\n    if (serverClientInfo) {\n      try {\n        var clientInfo = buildClientInfo(serverClientInfo, cryptoObj);\n        if (!StringUtils.isEmpty(clientInfo.uid) && !StringUtils.isEmpty(clientInfo.utid)) {\n          return \"\" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid;\n        }\n      } catch (e) {}\n    }\n    // default to \"sub\" claim\n    logger.verbose(\"No client info in response\");\n    return accountId;\n  };\n  /**\r\n   * Validates an entity: checks for all expected params\r\n   * @param entity\r\n   */\n  AccountEntity.isAccountEntity = function (entity) {\n    if (!entity) {\n      return false;\n    }\n    return entity.hasOwnProperty(\"homeAccountId\") && entity.hasOwnProperty(\"environment\") && entity.hasOwnProperty(\"realm\") && entity.hasOwnProperty(\"localAccountId\") && entity.hasOwnProperty(\"username\") && entity.hasOwnProperty(\"authorityType\");\n  };\n  /**\r\n   * Helper function to determine whether 2 accountInfo objects represent the same account\r\n   * @param accountA\r\n   * @param accountB\r\n   * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality\r\n   */\n  AccountEntity.accountInfoIsEqual = function (accountA, accountB, compareClaims) {\n    if (!accountA || !accountB) {\n      return false;\n    }\n    var claimsMatch = true; // default to true so as to not fail comparison below if compareClaims: false\n    if (compareClaims) {\n      var accountAClaims = accountA.idTokenClaims || {};\n      var accountBClaims = accountB.idTokenClaims || {};\n      // issued at timestamp and nonce are expected to change each time a new id token is acquired\n      claimsMatch = accountAClaims.iat === accountBClaims.iat && accountAClaims.nonce === accountBClaims.nonce;\n    }\n    return accountA.homeAccountId === accountB.homeAccountId && accountA.localAccountId === accountB.localAccountId && accountA.username === accountB.username && accountA.tenantId === accountB.tenantId && accountA.environment === accountB.environment && accountA.nativeAccountId === accountB.nativeAccountId && claimsMatch;\n  };\n  return AccountEntity;\n}();\nexport { AccountEntity };","map":{"version":3,"sources":["../../../src/cache/entities/AccountEntity.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    Separators,\r\n    CacheAccountType,\r\n    CacheType,\r\n    Constants,\r\n} from \"../../utils/Constants\";\r\nimport { Authority } from \"../../authority/Authority\";\r\nimport { AuthToken } from \"../../account/AuthToken\";\r\nimport { ICrypto } from \"../../crypto/ICrypto\";\r\nimport { buildClientInfo } from \"../../account/ClientInfo\";\r\nimport { StringUtils } from \"../../utils/StringUtils\";\r\nimport { AccountInfo } from \"../../account/AccountInfo\";\r\nimport { ClientAuthError } from \"../../error/ClientAuthError\";\r\nimport { AuthorityType } from \"../../authority/AuthorityType\";\r\nimport { Logger } from \"../../logger/Logger\";\r\nimport { TokenClaims } from \"../../account/TokenClaims\";\r\n\r\n/**\r\n * Type that defines required and optional parameters for an Account field (based on universal cache schema implemented by all MSALs).\r\n *\r\n * Key : Value Schema\r\n *\r\n * Key: <home_account_id>-<environment>-<realm*>\r\n *\r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      localAccountId: Original tenant-specific accountID, usually used for legacy cases\r\n *      username: primary username that represents the user, usually corresponds to preferred_username in the v2 endpt\r\n *      authorityType: Accounts authority type as a string\r\n *      name: Full name for the account, including given name and family name,\r\n *      clientInfo: Full base64 encoded client info received from ESTS\r\n *      lastModificationTime: last time this entity was modified in the cache\r\n *      lastModificationApp:\r\n *      idTokenClaims: Object containing claims parsed from ID token\r\n *      nativeAccountId: Account identifier on the native device\r\n * }\r\n */\r\nexport class AccountEntity {\r\n    homeAccountId: string;\r\n    environment: string;\r\n    realm: string;\r\n    localAccountId: string;\r\n    username: string;\r\n    authorityType: string;\r\n    name?: string;\r\n    clientInfo?: string;\r\n    lastModificationTime?: string;\r\n    lastModificationApp?: string;\r\n    cloudGraphHostName?: string;\r\n    msGraphHost?: string;\r\n    idTokenClaims?: TokenClaims;\r\n    nativeAccountId?: string;\r\n\r\n    /**\r\n     * Generate Account Id key component as per the schema: <home_account_id>-<environment>\r\n     */\r\n    generateAccountId(): string {\r\n        const accountId: Array<string> = [this.homeAccountId, this.environment];\r\n        return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\r\n    }\r\n\r\n    /**\r\n     * Generate Account Cache Key as per the schema: <home_account_id>-<environment>-<realm*>\r\n     */\r\n    generateAccountKey(): string {\r\n        return AccountEntity.generateAccountCacheKey({\r\n            homeAccountId: this.homeAccountId,\r\n            environment: this.environment,\r\n            tenantId: this.realm,\r\n            username: this.username,\r\n            localAccountId: this.localAccountId\r\n        });\r\n    }\r\n\r\n    /**\r\n     * returns the type of the cache (in this case account)\r\n     */\r\n    generateType(): number {\r\n        switch (this.authorityType) {\r\n            case CacheAccountType.ADFS_ACCOUNT_TYPE:\r\n                return CacheType.ADFS;\r\n            case CacheAccountType.MSAV1_ACCOUNT_TYPE:\r\n                return CacheType.MSA;\r\n            case CacheAccountType.MSSTS_ACCOUNT_TYPE:\r\n                return CacheType.MSSTS;\r\n            case CacheAccountType.GENERIC_ACCOUNT_TYPE:\r\n                return CacheType.GENERIC;\r\n            default: {\r\n                throw ClientAuthError.createUnexpectedAccountTypeError();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the AccountInfo interface for this account.\r\n     */\r\n    getAccountInfo(): AccountInfo {\r\n        return {\r\n            homeAccountId: this.homeAccountId,\r\n            environment: this.environment,\r\n            tenantId: this.realm,\r\n            username: this.username,\r\n            localAccountId: this.localAccountId,\r\n            name: this.name,\r\n            idTokenClaims: this.idTokenClaims,\r\n            nativeAccountId: this.nativeAccountId\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Generates account key from interface\r\n     * @param accountInterface\r\n     */\r\n    static generateAccountCacheKey(accountInterface: AccountInfo): string {\r\n        const accountKey = [\r\n            accountInterface.homeAccountId,\r\n            accountInterface.environment || Constants.EMPTY_STRING,\r\n            accountInterface.tenantId || Constants.EMPTY_STRING,\r\n        ];\r\n\r\n        return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\r\n    }\r\n\r\n    /**\r\n     * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.\r\n     * @param clientInfo\r\n     * @param authority\r\n     * @param idToken\r\n     * @param policy\r\n     */\r\n    static createAccount(\r\n        clientInfo: string,\r\n        homeAccountId: string,\r\n        idToken: AuthToken,\r\n        authority?: Authority,\r\n        cloudGraphHostName?: string,\r\n        msGraphHost?: string,\r\n        environment?: string,\r\n        nativeAccountId?: string\r\n    ): AccountEntity {\r\n        const account: AccountEntity = new AccountEntity();\r\n\r\n        account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;\r\n        account.clientInfo = clientInfo;\r\n        account.homeAccountId = homeAccountId;\r\n        account.nativeAccountId = nativeAccountId;\r\n\r\n        const env = environment || (authority && authority.getPreferredCache());\r\n\r\n        if (!env) {\r\n            throw ClientAuthError.createInvalidCacheEnvironmentError();\r\n        }\r\n\r\n        account.environment = env;\r\n        // non AAD scenarios can have empty realm\r\n        account.realm = idToken?.claims?.tid || Constants.EMPTY_STRING;\r\n\r\n        if (idToken) {\r\n            account.idTokenClaims = idToken.claims;\r\n\r\n            // How do you account for MSA CID here?\r\n            account.localAccountId = idToken?.claims?.oid || idToken?.claims?.sub || Constants.EMPTY_STRING;\r\n\r\n            /*\r\n             * In B2C scenarios the emails claim is used instead of preferred_username and it is an array.\r\n             * In most cases it will contain a single email. This field should not be relied upon if a custom \r\n             * policy is configured to return more than 1 email.\r\n             */\r\n            const preferredUsername = idToken?.claims?.preferred_username;\r\n            const email = (idToken?.claims?.emails) ? idToken.claims.emails[0] : null;\r\n            \r\n            account.username = preferredUsername || email || Constants.EMPTY_STRING;\r\n            account.name = idToken?.claims?.name;\r\n        }\r\n\r\n        account.cloudGraphHostName = cloudGraphHostName;\r\n        account.msGraphHost = msGraphHost;\r\n\r\n        return account;\r\n    }\r\n\r\n    /**\r\n     * Builds non-AAD/ADFS account.\r\n     * @param authority\r\n     * @param idToken\r\n     */\r\n    static createGenericAccount(\r\n        homeAccountId: string,\r\n        idToken: AuthToken,\r\n        authority?: Authority,\r\n        cloudGraphHostName?: string,\r\n        msGraphHost?: string,\r\n        environment?: string\r\n    ): AccountEntity {\r\n        const account: AccountEntity = new AccountEntity();\r\n\r\n        account.authorityType = (\r\n            authority &&\r\n            authority.authorityType === AuthorityType.Adfs\r\n        ) ? CacheAccountType.ADFS_ACCOUNT_TYPE : CacheAccountType.GENERIC_ACCOUNT_TYPE;\r\n        \r\n        account.homeAccountId = homeAccountId;\r\n        // non AAD scenarios can have empty realm\r\n        account.realm = Constants.EMPTY_STRING;\r\n\r\n        const env = environment || authority && authority.getPreferredCache();\r\n\r\n        if (!env) {\r\n            throw ClientAuthError.createInvalidCacheEnvironmentError();\r\n        }\r\n\r\n        if (idToken) {\r\n            // How do you account for MSA CID here?\r\n            account.localAccountId = idToken?.claims?.oid || idToken?.claims?.sub || Constants.EMPTY_STRING;\r\n            // upn claim for most ADFS scenarios\r\n            account.username = idToken?.claims?.upn || Constants.EMPTY_STRING;\r\n            account.name = idToken?.claims?.name || Constants.EMPTY_STRING;\r\n            account.idTokenClaims = idToken?.claims;\r\n        }\r\n\r\n        account.environment = env;\r\n\r\n        account.cloudGraphHostName = cloudGraphHostName;\r\n        account.msGraphHost = msGraphHost;\r\n\r\n        /*\r\n         * add uniqueName to claims\r\n         * account.name = idToken.claims.uniqueName;\r\n         */\r\n\r\n        return account;\r\n    }\r\n\r\n    /**\r\n     * Generate HomeAccountId from server response\r\n     * @param serverClientInfo\r\n     * @param authType\r\n     */\r\n    static generateHomeAccountId(\r\n        serverClientInfo: string,\r\n        authType: AuthorityType,\r\n        logger: Logger,\r\n        cryptoObj: ICrypto,\r\n        idToken?: AuthToken\r\n    ): string {\r\n\r\n        const accountId = idToken?.claims?.sub ? idToken.claims.sub : Constants.EMPTY_STRING;\r\n\r\n        // since ADFS does not have tid and does not set client_info\r\n        if (authType === AuthorityType.Adfs || authType === AuthorityType.Dsts) {\r\n            return accountId;\r\n        }\r\n\r\n        // for cases where there is clientInfo\r\n        if (serverClientInfo) {\r\n            try {\r\n                const clientInfo = buildClientInfo(serverClientInfo, cryptoObj);\r\n                if (!StringUtils.isEmpty(clientInfo.uid) && !StringUtils.isEmpty(clientInfo.utid)) {\r\n                    return `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`;\r\n                }\r\n            } catch (e) {}\r\n        }\r\n\r\n        // default to \"sub\" claim\r\n        logger.verbose(\"No client info in response\");\r\n        return accountId;\r\n    }\r\n\r\n    /**\r\n     * Validates an entity: checks for all expected params\r\n     * @param entity\r\n     */\r\n    static isAccountEntity(entity: object): boolean {\r\n\r\n        if (!entity) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            entity.hasOwnProperty(\"homeAccountId\") &&\r\n            entity.hasOwnProperty(\"environment\") &&\r\n            entity.hasOwnProperty(\"realm\") &&\r\n            entity.hasOwnProperty(\"localAccountId\") &&\r\n            entity.hasOwnProperty(\"username\") &&\r\n            entity.hasOwnProperty(\"authorityType\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Helper function to determine whether 2 accountInfo objects represent the same account\r\n     * @param accountA\r\n     * @param accountB\r\n     * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality\r\n     */\r\n    static accountInfoIsEqual(accountA: AccountInfo | null, accountB: AccountInfo | null, compareClaims?: boolean): boolean {\r\n        if (!accountA || !accountB) {\r\n            return false;\r\n        }\r\n\r\n        let claimsMatch = true; // default to true so as to not fail comparison below if compareClaims: false\r\n        if (compareClaims) {\r\n            const accountAClaims = (accountA.idTokenClaims || {}) as TokenClaims;\r\n            const accountBClaims = (accountB.idTokenClaims || {}) as TokenClaims;\r\n\r\n            // issued at timestamp and nonce are expected to change each time a new id token is acquired\r\n            claimsMatch = (accountAClaims.iat === accountBClaims.iat) &&\r\n            (accountAClaims.nonce === accountBClaims.nonce);\r\n        }\r\n\r\n        return (accountA.homeAccountId === accountB.homeAccountId) &&\r\n            (accountA.localAccountId === accountB.localAccountId) &&\r\n            (accountA.username === accountB.username) &&\r\n            (accountA.tenantId === accountB.tenantId) &&\r\n            (accountA.environment === accountB.environment) &&\r\n            (accountA.nativeAccountId === accountB.nativeAccountId) &&\r\n            claimsMatch;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}