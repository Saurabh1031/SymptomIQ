{"ast":null,"code":"/*! @azure/msal-common v13.3.1 2023-10-27 */\n'use strict';\n\nimport { ClientConfigurationError } from '../error/ClientConfigurationError.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { StringUtils } from '../utils/StringUtils.js';\nimport { AADAuthorityConstants, Constants } from '../utils/Constants.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Url object class which can perform various transformations on url strings.\r\n */\nvar UrlString = /** @class */function () {\n  function UrlString(url) {\n    this._urlString = url;\n    if (StringUtils.isEmpty(this._urlString)) {\n      // Throws error if url is empty\n      throw ClientConfigurationError.createUrlEmptyError();\n    }\n    if (StringUtils.isEmpty(this.getHash())) {\n      this._urlString = UrlString.canonicalizeUri(url);\n    }\n  }\n  Object.defineProperty(UrlString.prototype, \"urlString\", {\n    get: function () {\n      return this._urlString;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Ensure urls are lower case and end with a / character.\r\n   * @param url\r\n   */\n  UrlString.canonicalizeUri = function (url) {\n    if (url) {\n      var lowerCaseUrl = url.toLowerCase();\n      if (StringUtils.endsWith(lowerCaseUrl, \"?\")) {\n        lowerCaseUrl = lowerCaseUrl.slice(0, -1);\n      } else if (StringUtils.endsWith(lowerCaseUrl, \"?/\")) {\n        lowerCaseUrl = lowerCaseUrl.slice(0, -2);\n      }\n      if (!StringUtils.endsWith(lowerCaseUrl, \"/\")) {\n        lowerCaseUrl += \"/\";\n      }\n      return lowerCaseUrl;\n    }\n    return url;\n  };\n  /**\r\n   * Throws if urlString passed is not a valid authority URI string.\r\n   */\n  UrlString.prototype.validateAsUri = function () {\n    // Attempts to parse url for uri components\n    var components;\n    try {\n      components = this.getUrlComponents();\n    } catch (e) {\n      throw ClientConfigurationError.createUrlParseError(e);\n    }\n    // Throw error if URI or path segments are not parseable.\n    if (!components.HostNameAndPort || !components.PathSegments) {\n      throw ClientConfigurationError.createUrlParseError(\"Given url string: \" + this.urlString);\n    }\n    // Throw error if uri is insecure.\n    if (!components.Protocol || components.Protocol.toLowerCase() !== \"https:\") {\n      throw ClientConfigurationError.createInsecureAuthorityUriError(this.urlString);\n    }\n  };\n  /**\r\n   * Given a url and a query string return the url with provided query string appended\r\n   * @param url\r\n   * @param queryString\r\n   */\n  UrlString.appendQueryString = function (url, queryString) {\n    if (StringUtils.isEmpty(queryString)) {\n      return url;\n    }\n    return url.indexOf(\"?\") < 0 ? url + \"?\" + queryString : url + \"&\" + queryString;\n  };\n  /**\r\n   * Returns a url with the hash removed\r\n   * @param url\r\n   */\n  UrlString.removeHashFromUrl = function (url) {\n    return UrlString.canonicalizeUri(url.split(\"#\")[0]);\n  };\n  /**\r\n   * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d\r\n   * @param href The url\r\n   * @param tenantId The tenant id to replace\r\n   */\n  UrlString.prototype.replaceTenantPath = function (tenantId) {\n    var urlObject = this.getUrlComponents();\n    var pathArray = urlObject.PathSegments;\n    if (tenantId && pathArray.length !== 0 && (pathArray[0] === AADAuthorityConstants.COMMON || pathArray[0] === AADAuthorityConstants.ORGANIZATIONS)) {\n      pathArray[0] = tenantId;\n    }\n    return UrlString.constructAuthorityUriFromObject(urlObject);\n  };\n  /**\r\n   * Returns the anchor part(#) of the URL\r\n   */\n  UrlString.prototype.getHash = function () {\n    return UrlString.parseHash(this.urlString);\n  };\n  /**\r\n   * Parses out the components from a url string.\r\n   * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.\r\n   */\n  UrlString.prototype.getUrlComponents = function () {\n    // https://gist.github.com/curtisz/11139b2cfcaef4a261e0\n    var regEx = RegExp(\"^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?\");\n    // If url string does not match regEx, we throw an error\n    var match = this.urlString.match(regEx);\n    if (!match) {\n      throw ClientConfigurationError.createUrlParseError(\"Given url string: \" + this.urlString);\n    }\n    // Url component object\n    var urlComponents = {\n      Protocol: match[1],\n      HostNameAndPort: match[4],\n      AbsolutePath: match[5],\n      QueryString: match[7]\n    };\n    var pathSegments = urlComponents.AbsolutePath.split(\"/\");\n    pathSegments = pathSegments.filter(function (val) {\n      return val && val.length > 0;\n    }); // remove empty elements\n    urlComponents.PathSegments = pathSegments;\n    if (!StringUtils.isEmpty(urlComponents.QueryString) && urlComponents.QueryString.endsWith(\"/\")) {\n      urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length - 1);\n    }\n    return urlComponents;\n  };\n  UrlString.getDomainFromUrl = function (url) {\n    var regEx = RegExp(\"^([^:/?#]+://)?([^/?#]*)\");\n    var match = url.match(regEx);\n    if (!match) {\n      throw ClientConfigurationError.createUrlParseError(\"Given url string: \" + url);\n    }\n    return match[2];\n  };\n  UrlString.getAbsoluteUrl = function (relativeUrl, baseUrl) {\n    if (relativeUrl[0] === Constants.FORWARD_SLASH) {\n      var url = new UrlString(baseUrl);\n      var baseComponents = url.getUrlComponents();\n      return baseComponents.Protocol + \"//\" + baseComponents.HostNameAndPort + relativeUrl;\n    }\n    return relativeUrl;\n  };\n  /**\r\n   * Parses hash string from given string. Returns empty string if no hash symbol is found.\r\n   * @param hashString\r\n   */\n  UrlString.parseHash = function (hashString) {\n    var hashIndex1 = hashString.indexOf(\"#\");\n    var hashIndex2 = hashString.indexOf(\"#/\");\n    if (hashIndex2 > -1) {\n      return hashString.substring(hashIndex2 + 2);\n    } else if (hashIndex1 > -1) {\n      return hashString.substring(hashIndex1 + 1);\n    }\n    return Constants.EMPTY_STRING;\n  };\n  /**\r\n   * Parses query string from given string. Returns empty string if no query symbol is found.\r\n   * @param queryString\r\n   */\n  UrlString.parseQueryString = function (queryString) {\n    var queryIndex1 = queryString.indexOf(\"?\");\n    var queryIndex2 = queryString.indexOf(\"/?\");\n    if (queryIndex2 > -1) {\n      return queryString.substring(queryIndex2 + 2);\n    } else if (queryIndex1 > -1) {\n      return queryString.substring(queryIndex1 + 1);\n    }\n    return Constants.EMPTY_STRING;\n  };\n  UrlString.constructAuthorityUriFromObject = function (urlObject) {\n    return new UrlString(urlObject.Protocol + \"//\" + urlObject.HostNameAndPort + \"/\" + urlObject.PathSegments.join(\"/\"));\n  };\n  /**\r\n   * Returns URL hash as server auth code response object.\r\n   */\n  UrlString.getDeserializedHash = function (hash) {\n    // Check if given hash is empty\n    if (StringUtils.isEmpty(hash)) {\n      return {};\n    }\n    // Strip the # symbol if present\n    var parsedHash = UrlString.parseHash(hash);\n    // If # symbol was not present, above will return empty string, so give original hash value\n    var deserializedHash = StringUtils.queryStringToObject(StringUtils.isEmpty(parsedHash) ? hash : parsedHash);\n    // Check if deserialization didn't work\n    if (!deserializedHash) {\n      throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedHash));\n    }\n    return deserializedHash;\n  };\n  /**\r\n   * Returns URL query string as server auth code response object.\r\n   */\n  UrlString.getDeserializedQueryString = function (query) {\n    // Check if given query is empty\n    if (StringUtils.isEmpty(query)) {\n      return {};\n    }\n    // Strip the ? symbol if present\n    var parsedQueryString = UrlString.parseQueryString(query);\n    // If ? symbol was not present, above will return empty string, so give original query value\n    var deserializedQueryString = StringUtils.queryStringToObject(StringUtils.isEmpty(parsedQueryString) ? query : parsedQueryString);\n    // Check if deserialization didn't work\n    if (!deserializedQueryString) {\n      throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedQueryString));\n    }\n    return deserializedQueryString;\n  };\n  /**\r\n   * Check if the hash of the URL string contains known properties\r\n   */\n  UrlString.hashContainsKnownProperties = function (hash) {\n    if (StringUtils.isEmpty(hash) || hash.indexOf(\"=\") < 0) {\n      // Hash doesn't contain key/value pairs\n      return false;\n    }\n    var parameters = UrlString.getDeserializedHash(hash);\n    return !!(parameters.code || parameters.error_description || parameters.error || parameters.state);\n  };\n  return UrlString;\n}();\nexport { UrlString };","map":{"version":3,"sources":["../../src/url/UrlString.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { ServerAuthorizationCodeResponse } from \"../response/ServerAuthorizationCodeResponse\";\r\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\nimport { IUri } from \"./IUri\";\r\nimport { AADAuthorityConstants, Constants } from \"../utils/Constants\";\r\n\r\n/**\r\n * Url object class which can perform various transformations on url strings.\r\n */\r\nexport class UrlString {\r\n\r\n    // internal url string field\r\n    private _urlString: string;\r\n    public get urlString(): string {\r\n        return this._urlString;\r\n    }\r\n\r\n    constructor(url: string) {\r\n        this._urlString = url;\r\n        if (StringUtils.isEmpty(this._urlString)) {\r\n            // Throws error if url is empty\r\n            throw ClientConfigurationError.createUrlEmptyError();\r\n        }\r\n\r\n        if (StringUtils.isEmpty(this.getHash())) {\r\n            this._urlString = UrlString.canonicalizeUri(url);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Ensure urls are lower case and end with a / character.\r\n     * @param url\r\n     */\r\n    static canonicalizeUri(url: string): string {\r\n        if (url) {\r\n            let lowerCaseUrl = url.toLowerCase();\r\n\r\n            if (StringUtils.endsWith(lowerCaseUrl, \"?\")) {\r\n                lowerCaseUrl = lowerCaseUrl.slice(0, -1);\r\n            } else if (StringUtils.endsWith(lowerCaseUrl, \"?/\")) {\r\n                lowerCaseUrl = lowerCaseUrl.slice(0, -2);\r\n            }\r\n\r\n            if (!StringUtils.endsWith(lowerCaseUrl, \"/\")) {\r\n                lowerCaseUrl += \"/\";\r\n            }\r\n\r\n            return lowerCaseUrl;\r\n        }\r\n\r\n        return url;\r\n    }\r\n\r\n    /**\r\n     * Throws if urlString passed is not a valid authority URI string.\r\n     */\r\n    validateAsUri(): void {\r\n        // Attempts to parse url for uri components\r\n        let components;\r\n        try {\r\n            components = this.getUrlComponents();\r\n        } catch (e) {\r\n            throw ClientConfigurationError.createUrlParseError(e);\r\n        }\r\n\r\n        // Throw error if URI or path segments are not parseable.\r\n        if (!components.HostNameAndPort || !components.PathSegments) {\r\n            throw ClientConfigurationError.createUrlParseError(`Given url string: ${this.urlString}`);\r\n        }\r\n\r\n        // Throw error if uri is insecure.\r\n        if(!components.Protocol || components.Protocol.toLowerCase() !== \"https:\") {\r\n            throw ClientConfigurationError.createInsecureAuthorityUriError(this.urlString);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a url and a query string return the url with provided query string appended\r\n     * @param url\r\n     * @param queryString\r\n     */\r\n    static appendQueryString(url: string, queryString: string): string {\r\n        if (StringUtils.isEmpty(queryString)) {\r\n            return url;\r\n        }\r\n\r\n        return url.indexOf(\"?\") < 0 ? `${url}?${queryString}` : `${url}&${queryString}`;\r\n    }\r\n\r\n    /**\r\n     * Returns a url with the hash removed\r\n     * @param url\r\n     */\r\n    static removeHashFromUrl(url: string): string {\r\n        return UrlString.canonicalizeUri(url.split(\"#\")[0]);\r\n    }\r\n\r\n    /**\r\n     * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d\r\n     * @param href The url\r\n     * @param tenantId The tenant id to replace\r\n     */\r\n    replaceTenantPath(tenantId: string): UrlString {\r\n        const urlObject = this.getUrlComponents();\r\n        const pathArray = urlObject.PathSegments;\r\n        if (tenantId && (pathArray.length !== 0 && (pathArray[0] === AADAuthorityConstants.COMMON || pathArray[0] === AADAuthorityConstants.ORGANIZATIONS))) {\r\n            pathArray[0] = tenantId;\r\n        }\r\n        return UrlString.constructAuthorityUriFromObject(urlObject);\r\n    }\r\n\r\n    /**\r\n     * Returns the anchor part(#) of the URL\r\n     */\r\n    getHash(): string {\r\n        return UrlString.parseHash(this.urlString);\r\n    }\r\n\r\n    /**\r\n     * Parses out the components from a url string.\r\n     * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.\r\n     */\r\n    getUrlComponents(): IUri {\r\n        // https://gist.github.com/curtisz/11139b2cfcaef4a261e0\r\n        const regEx = RegExp(\"^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?\");\r\n\r\n        // If url string does not match regEx, we throw an error\r\n        const match = this.urlString.match(regEx);\r\n        if (!match) {\r\n            throw ClientConfigurationError.createUrlParseError(`Given url string: ${this.urlString}`);\r\n        }\r\n\r\n        // Url component object\r\n        const urlComponents = {\r\n            Protocol: match[1],\r\n            HostNameAndPort: match[4],\r\n            AbsolutePath: match[5],\r\n            QueryString: match[7]\r\n        } as IUri;\r\n\r\n        let pathSegments = urlComponents.AbsolutePath.split(\"/\");\r\n        pathSegments = pathSegments.filter((val) => val && val.length > 0); // remove empty elements\r\n        urlComponents.PathSegments = pathSegments;\r\n\r\n        if (!StringUtils.isEmpty(urlComponents.QueryString) && urlComponents.QueryString.endsWith(\"/\")) {\r\n            urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length-1);\r\n        }\r\n        return urlComponents;\r\n    }\r\n\r\n    static getDomainFromUrl(url: string): string {\r\n        const regEx = RegExp(\"^([^:/?#]+://)?([^/?#]*)\");\r\n\r\n        const match = url.match(regEx);\r\n\r\n        if (!match) {\r\n            throw ClientConfigurationError.createUrlParseError(`Given url string: ${url}`);\r\n        }\r\n\r\n        return match[2];\r\n    }\r\n\r\n    static getAbsoluteUrl(relativeUrl: string, baseUrl: string): string {\r\n        if (relativeUrl[0] === Constants.FORWARD_SLASH) {\r\n            const url = new UrlString(baseUrl);\r\n            const baseComponents = url.getUrlComponents();\r\n\r\n            return baseComponents.Protocol + \"//\" + baseComponents.HostNameAndPort + relativeUrl;\r\n        }\r\n\r\n        return relativeUrl;\r\n    }\r\n\r\n    /**\r\n     * Parses hash string from given string. Returns empty string if no hash symbol is found.\r\n     * @param hashString\r\n     */\r\n    static parseHash(hashString: string): string {\r\n        const hashIndex1 = hashString.indexOf(\"#\");\r\n        const hashIndex2 = hashString.indexOf(\"#/\");\r\n        if (hashIndex2 > -1) {\r\n            return hashString.substring(hashIndex2 + 2);\r\n        } else if (hashIndex1 > -1) {\r\n            return hashString.substring(hashIndex1 + 1);\r\n        }\r\n        return Constants.EMPTY_STRING;\r\n    }\r\n\r\n    /**\r\n     * Parses query string from given string. Returns empty string if no query symbol is found.\r\n     * @param queryString\r\n     */\r\n    static parseQueryString(queryString: string): string {\r\n        const queryIndex1 = queryString.indexOf(\"?\");\r\n        const queryIndex2 = queryString.indexOf(\"/?\");\r\n        if (queryIndex2 > -1) {\r\n            return queryString.substring(queryIndex2 + 2);\r\n        } else if (queryIndex1 > -1) {\r\n            return queryString.substring(queryIndex1 + 1);\r\n        }\r\n        return Constants.EMPTY_STRING;\r\n    }\r\n\r\n    static constructAuthorityUriFromObject(urlObject: IUri): UrlString {\r\n        return new UrlString(urlObject.Protocol + \"//\" + urlObject.HostNameAndPort + \"/\" + urlObject.PathSegments.join(\"/\"));\r\n    }\r\n\r\n    /**\r\n     * Returns URL hash as server auth code response object.\r\n     */\r\n    static getDeserializedHash(hash: string): ServerAuthorizationCodeResponse {\r\n        // Check if given hash is empty\r\n        if (StringUtils.isEmpty(hash)) {\r\n            return {};\r\n        }\r\n        // Strip the # symbol if present\r\n        const parsedHash = UrlString.parseHash(hash);\r\n        // If # symbol was not present, above will return empty string, so give original hash value\r\n        const deserializedHash: ServerAuthorizationCodeResponse = StringUtils.queryStringToObject<ServerAuthorizationCodeResponse>(StringUtils.isEmpty(parsedHash) ? hash : parsedHash);\r\n        // Check if deserialization didn't work\r\n        if (!deserializedHash) {\r\n            throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedHash));\r\n        }\r\n        return deserializedHash;\r\n    }\r\n\r\n    /**\r\n     * Returns URL query string as server auth code response object.\r\n     */\r\n    static getDeserializedQueryString(query: string): ServerAuthorizationCodeResponse {\r\n        // Check if given query is empty\r\n        if (StringUtils.isEmpty(query)) {\r\n            return {};\r\n        }\r\n        // Strip the ? symbol if present\r\n        const parsedQueryString = UrlString.parseQueryString(query);\r\n        // If ? symbol was not present, above will return empty string, so give original query value\r\n        const deserializedQueryString: ServerAuthorizationCodeResponse = StringUtils.queryStringToObject<ServerAuthorizationCodeResponse>(StringUtils.isEmpty(parsedQueryString) ? query : parsedQueryString);\r\n        // Check if deserialization didn't work\r\n        if (!deserializedQueryString) {\r\n            throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedQueryString));\r\n        }\r\n        return deserializedQueryString;\r\n    }\r\n\r\n    /**\r\n     * Check if the hash of the URL string contains known properties\r\n     */\r\n    static hashContainsKnownProperties(hash: string): boolean {\r\n        if (StringUtils.isEmpty(hash) || hash.indexOf(\"=\") < 0) {\r\n            // Hash doesn't contain key/value pairs\r\n            return false;\r\n        }\r\n\r\n        const parameters: ServerAuthorizationCodeResponse = UrlString.getDeserializedHash(hash);\r\n        return !!(\r\n            parameters.code ||\r\n            parameters.error_description ||\r\n            parameters.error ||\r\n            parameters.state\r\n        );\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}