{"ast":null,"code":"/*! @azure/msal-common v13.3.1 2023-10-27 */\n'use strict';\n\nimport { __extends, __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { BaseClient } from './BaseClient.js';\nimport { AuthToken } from '../account/AuthToken.js';\nimport { TimeUtils } from '../utils/TimeUtils.js';\nimport { RefreshTokenClient } from './RefreshTokenClient.js';\nimport { ClientAuthError, ClientAuthErrorMessage } from '../error/ClientAuthError.js';\nimport { ClientConfigurationError } from '../error/ClientConfigurationError.js';\nimport { ResponseHandler } from '../response/ResponseHandler.js';\nimport { CacheOutcome } from '../utils/Constants.js';\nimport { StringUtils } from '../utils/StringUtils.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nvar SilentFlowClient = /** @class */function (_super) {\n  __extends(SilentFlowClient, _super);\n  function SilentFlowClient(configuration, performanceClient) {\n    return _super.call(this, configuration, performanceClient) || this;\n  }\n  /**\r\n   * Retrieves a token from cache if it is still valid, or uses the cached refresh token to renew\r\n   * the given token and returns the renewed token\r\n   * @param request\r\n   */\n  SilentFlowClient.prototype.acquireToken = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_1, refreshTokenClient;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n            return [4 /*yield*/, this.acquireCachedToken(request)];\n          case 1:\n            return [2 /*return*/, _a.sent()];\n          case 2:\n            e_1 = _a.sent();\n            if (e_1 instanceof ClientAuthError && e_1.errorCode === ClientAuthErrorMessage.tokenRefreshRequired.code) {\n              refreshTokenClient = new RefreshTokenClient(this.config, this.performanceClient);\n              return [2 /*return*/, refreshTokenClient.acquireTokenByRefreshToken(request)];\n            } else {\n              throw e_1;\n            }\n          case 3:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Retrieves token from cache or throws an error if it must be refreshed.\r\n   * @param request\r\n   */\n  SilentFlowClient.prototype.acquireCachedToken = function (request) {\n    var _a, _b, _c, _d, _e;\n    return __awaiter(this, void 0, void 0, function () {\n      var environment, cacheRecord;\n      return __generator(this, function (_f) {\n        switch (_f.label) {\n          case 0:\n            // Cannot renew token if no request object is given.\n            if (!request) {\n              throw ClientConfigurationError.createEmptyTokenRequestError();\n            }\n            if (request.forceRefresh) {\n              // Must refresh due to present force_refresh flag.\n              (_a = this.serverTelemetryManager) === null || _a === void 0 ? void 0 : _a.setCacheOutcome(CacheOutcome.FORCE_REFRESH);\n              this.logger.info(\"SilentFlowClient:acquireCachedToken - Skipping cache because forceRefresh is true.\");\n              throw ClientAuthError.createRefreshRequiredError();\n            } else if (!this.config.cacheOptions.claimsBasedCachingEnabled && !StringUtils.isEmptyObj(request.claims)) {\n              // Must refresh due to presence of claims in request preventing cache lookup\n              (_b = this.serverTelemetryManager) === null || _b === void 0 ? void 0 : _b.setCacheOutcome(CacheOutcome.CLAIMS_REQUESTED_CACHE_SKIPPED);\n              this.logger.info(\"SilentFlowClient:acquireCachedToken - Skipping cache because claims-based caching is disabled and claims were requested.\");\n              throw ClientAuthError.createRefreshRequiredError();\n            }\n            // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\n            if (!request.account) {\n              throw ClientAuthError.createNoAccountInSilentRequestError();\n            }\n            environment = request.authority || this.authority.getPreferredCache();\n            cacheRecord = this.cacheManager.readCacheRecord(request.account, request, environment);\n            if (!cacheRecord.accessToken) {\n              // Must refresh due to non-existent access_token.\n              (_c = this.serverTelemetryManager) === null || _c === void 0 ? void 0 : _c.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);\n              this.logger.info(\"SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.\");\n              throw ClientAuthError.createRefreshRequiredError();\n            } else if (TimeUtils.wasClockTurnedBack(cacheRecord.accessToken.cachedAt) || TimeUtils.isTokenExpired(cacheRecord.accessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {\n              // Must refresh due to expired access_token.\n              (_d = this.serverTelemetryManager) === null || _d === void 0 ? void 0 : _d.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);\n              this.logger.info(\"SilentFlowClient:acquireCachedToken - Cached access token is expired or will expire within \" + this.config.systemOptions.tokenRenewalOffsetSeconds + \" seconds.\");\n              throw ClientAuthError.createRefreshRequiredError();\n            } else if (cacheRecord.accessToken.refreshOn && TimeUtils.isTokenExpired(cacheRecord.accessToken.refreshOn, 0)) {\n              // Must refresh due to the refresh_in value.\n              (_e = this.serverTelemetryManager) === null || _e === void 0 ? void 0 : _e.setCacheOutcome(CacheOutcome.REFRESH_CACHED_ACCESS_TOKEN);\n              this.logger.info(\"SilentFlowClient:acquireCachedToken - Cached access token's refreshOn property has been exceeded'.\");\n              throw ClientAuthError.createRefreshRequiredError();\n            }\n            if (this.config.serverTelemetryManager) {\n              this.config.serverTelemetryManager.incrementCacheHits();\n            }\n            return [4 /*yield*/, this.generateResultFromCacheRecord(cacheRecord, request)];\n          case 1:\n            return [2 /*return*/, _f.sent()];\n        }\n      });\n    });\n  };\n  /**\r\n   * Helper function to build response object from the CacheRecord\r\n   * @param cacheRecord\r\n   */\n  SilentFlowClient.prototype.generateResultFromCacheRecord = function (cacheRecord, request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var idTokenObj, authTime;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (cacheRecord.idToken) {\n              idTokenObj = new AuthToken(cacheRecord.idToken.secret, this.config.cryptoInterface);\n            }\n            // token max_age check\n            if (request.maxAge || request.maxAge === 0) {\n              authTime = idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.auth_time;\n              if (!authTime) {\n                throw ClientAuthError.createAuthTimeNotFoundError();\n              }\n              AuthToken.checkMaxAge(authTime, request.maxAge);\n            }\n            return [4 /*yield*/, ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, cacheRecord, true, request, idTokenObj)];\n          case 1:\n            return [2 /*return*/, _a.sent()];\n        }\n      });\n    });\n  };\n  return SilentFlowClient;\n}(BaseClient);\nexport { SilentFlowClient };","map":{"version":3,"sources":["../../src/client/SilentFlowClient.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { BaseClient } from \"./BaseClient\";\r\nimport { ClientConfiguration } from \"../config/ClientConfiguration\";\r\nimport { CommonSilentFlowRequest } from \"../request/CommonSilentFlowRequest\";\r\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\r\nimport { AuthToken } from \"../account/AuthToken\";\r\nimport { TimeUtils } from \"../utils/TimeUtils\";\r\nimport { RefreshTokenClient } from \"./RefreshTokenClient\";\r\nimport { ClientAuthError, ClientAuthErrorMessage } from \"../error/ClientAuthError\";\r\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\r\nimport { ResponseHandler } from \"../response/ResponseHandler\";\r\nimport { CacheRecord } from \"../cache/entities/CacheRecord\";\r\nimport { CacheOutcome } from \"../utils/Constants\";\r\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\n\r\nexport class SilentFlowClient extends BaseClient {\r\n    \r\n    constructor(configuration: ClientConfiguration, performanceClient?: IPerformanceClient) {\r\n        super(configuration,performanceClient);\r\n    }\r\n    \r\n    /**\r\n     * Retrieves a token from cache if it is still valid, or uses the cached refresh token to renew\r\n     * the given token and returns the renewed token\r\n     * @param request\r\n     */\r\n    async acquireToken(request: CommonSilentFlowRequest): Promise<AuthenticationResult> {\r\n        try {\r\n            return await this.acquireCachedToken(request);\r\n        } catch (e) {\r\n            if (e instanceof ClientAuthError && e.errorCode === ClientAuthErrorMessage.tokenRefreshRequired.code) {\r\n                const refreshTokenClient = new RefreshTokenClient(this.config, this.performanceClient);\r\n                return refreshTokenClient.acquireTokenByRefreshToken(request);\r\n            } else {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Retrieves token from cache or throws an error if it must be refreshed.\r\n     * @param request\r\n     */\r\n    async acquireCachedToken(request: CommonSilentFlowRequest): Promise<AuthenticationResult> {\r\n        // Cannot renew token if no request object is given.\r\n        if (!request) {\r\n            throw ClientConfigurationError.createEmptyTokenRequestError();\r\n        }\r\n\r\n        if (request.forceRefresh) {\r\n            // Must refresh due to present force_refresh flag.\r\n            this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.FORCE_REFRESH);\r\n            this.logger.info(\"SilentFlowClient:acquireCachedToken - Skipping cache because forceRefresh is true.\");\r\n            throw ClientAuthError.createRefreshRequiredError();\r\n        } else if (!this.config.cacheOptions.claimsBasedCachingEnabled && !StringUtils.isEmptyObj(request.claims)) {\r\n            // Must refresh due to presence of claims in request preventing cache lookup\r\n            this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.CLAIMS_REQUESTED_CACHE_SKIPPED);\r\n            this.logger.info(\"SilentFlowClient:acquireCachedToken - Skipping cache because claims-based caching is disabled and claims were requested.\");\r\n            throw ClientAuthError.createRefreshRequiredError();\r\n        }\r\n\r\n        // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\r\n        if (!request.account) {\r\n            throw ClientAuthError.createNoAccountInSilentRequestError();\r\n        }\r\n\r\n        const environment = request.authority || this.authority.getPreferredCache();\r\n\r\n        const cacheRecord = this.cacheManager.readCacheRecord(request.account, request, environment);\r\n\r\n        if (!cacheRecord.accessToken) {\r\n            // Must refresh due to non-existent access_token.\r\n            this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);\r\n            this.logger.info(\"SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.\");\r\n            throw ClientAuthError.createRefreshRequiredError();\r\n        } else if (\r\n            TimeUtils.wasClockTurnedBack(cacheRecord.accessToken.cachedAt) ||\r\n            TimeUtils.isTokenExpired(cacheRecord.accessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)\r\n        ) {\r\n            // Must refresh due to expired access_token.\r\n            this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);\r\n            this.logger.info(`SilentFlowClient:acquireCachedToken - Cached access token is expired or will expire within ${this.config.systemOptions.tokenRenewalOffsetSeconds} seconds.`);\r\n            throw ClientAuthError.createRefreshRequiredError();\r\n        } else if (cacheRecord.accessToken.refreshOn && TimeUtils.isTokenExpired(cacheRecord.accessToken.refreshOn, 0)) {\r\n            // Must refresh due to the refresh_in value.\r\n            this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.REFRESH_CACHED_ACCESS_TOKEN);\r\n            this.logger.info(\"SilentFlowClient:acquireCachedToken - Cached access token's refreshOn property has been exceeded'.\");\r\n            throw ClientAuthError.createRefreshRequiredError();\r\n        }\r\n\r\n        if (this.config.serverTelemetryManager) {\r\n            this.config.serverTelemetryManager.incrementCacheHits();\r\n        }\r\n\r\n        return await this.generateResultFromCacheRecord(cacheRecord, request);\r\n    }\r\n\r\n    /**\r\n     * Helper function to build response object from the CacheRecord\r\n     * @param cacheRecord\r\n     */\r\n    private async generateResultFromCacheRecord(cacheRecord: CacheRecord, request: CommonSilentFlowRequest): Promise<AuthenticationResult> {\r\n        let idTokenObj: AuthToken | undefined;\r\n        if (cacheRecord.idToken) {\r\n            idTokenObj = new AuthToken(cacheRecord.idToken.secret, this.config.cryptoInterface);\r\n        }\r\n\r\n        // token max_age check\r\n        if (request.maxAge || (request.maxAge === 0)) {\r\n            const authTime = idTokenObj?.claims.auth_time;\r\n            if (!authTime) {\r\n                throw ClientAuthError.createAuthTimeNotFoundError();\r\n            }\r\n\r\n            AuthToken.checkMaxAge(authTime, request.maxAge);\r\n        }\r\n\r\n        return await ResponseHandler.generateAuthenticationResult(\r\n            this.cryptoUtils,\r\n            this.authority,\r\n            cacheRecord,\r\n            true,\r\n            request,\r\n            idTokenObj\r\n        );\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}